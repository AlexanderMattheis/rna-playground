<!--
University of Freiburg WS 2017/2018
Chair for Bioinformatics
Supervisor: Martin Raden
Author: Alexander Mattheis
-->

<div id="algorithm_description">
    <div class="description">
        The progressive alignment approach by
        <a href="https://doi.org/10.1007/BF02603120">Da-Fei Feng, Russell F. Doolittle (1987)</a>
        computes a multi-sequence-alignment (MSA) of a set of sequences.
        This algorithm shows an approximative alignment approach,
        which finds considerable solutions in a reasonable time.
        <br>
        <br>
        The further below implemented version of this algorithm is a
        combination of several Feng-Doolittle approaches and the affine alignment approach
        by <a href="https://doi.org/10.1016/0022-2836(82)90398-9">Osamu Gotoh (1982)</a>.
        <br>
        After a pairwise alignment of all input sequences
        with <a href="http://rna.informatik.uni-freiburg.de/Teaching/index.jsp?toolName=Gotoh">Gotoh</a>
        to compute the similarity-scores,
        this altered <a href="10.1016/s0076-6879(96)66023-6">Feng-Doolittle (1996)</a> approach
        uses our, for affine alignment modified similarity-to-distance transformation-formula

        $$\quad D(a,b) = -ln(S^{eff}_{a,b} \cdot f)$$

        where $f = 1$ (originally $f = 100$)
        <br>
        and
        $$\quad S^{eff}_{a,b} = \frac{S(a,b) - S^{rand}_{a,b}}{S^{max}_{a,b} - S^{rand}_{a,b}}$$

        where <br>
        <div class="row">
            <div class="colW150">$S(a,b)$</div>
            <div class="colW400">observed score from the alignment of sequence $a$ with sequence $b$</div>
	    </div>

        <div class="row">
            <div class="colW150"> $S^{max}_{a,b} = \cfrac{S(a,a)+S(b,b)}{2}$</div>
            <div class="colW400">average score from the alignment of both sequences with themselves</div>
	    </div>

        The computation of $S^{rand}_{a,b}$ is done with an approximate formula
        which has been adapted, <br>
        because of the fusion with <a href="https://doi.org/10.1016/0022-2836(82)90398-9">Gotoh</a>.
        The new formula is therefore
        $$
        \quad
        S^{rand}_{a,b} =
        \frac{1}{L_{a,b}}
        \bigg(
        \sum_{i \in \mathbb{A}(a)} \sum_{j \in \mathbb{A}(b)}
        s(i,i) \cdot N_a(i) \cdot N_b(j)
        \bigg)
        + N_{a,b}(\_^e) \cdot \beta
        + N_{a,b}(\_^s) \cdot \alpha
        $$

        where <br>
        <div class="row">
            <div class="colW150">$L_{a,b}$</div>
            <div class="colW400">number of columns in the alignment of $a,b$</div>
	    </div>

        <div class="row">
            <div class="colW150">$\mathbb{A}(a), \mathbb{A}(b)$</div>
            <div class="colW400">alphabet-sets of sequences $a$ and $b$</div>
        </div>

        <div class="row">
            <div class="colW150">$s(i,i)$</div>
            <div class="colW400">similarity-score for a match with character $i$</div>
        </div>

        <div class="row">
            <div class="colW150">$N_a(i), N_b(j)$</div>
            <div class="colW400">absolute frequency of characters $i$ and $j$ in sequences $a$ and $b$</div>
        </div>

        <div class="row">
            <div class="colW150">$N_{a,b}(\_^e)$</div>
            <div class="colW400">absolute frequency of gaps (enlargements)</div>
        </div>

        <div class="row">
            <div class="colW150">$N_{a,b}(\_^s)$</div>
            <div class="colW400">absolute frequency of gap starts (adaptation for Gotoh)</div>
        </div>

        <div class="row">
            <div class="colW150">$\alpha, \beta$</div>
            <div class="colW400">
                parameters from
                <a href="http://rna.informatik.uni-freiburg.de/Teaching/index.jsp?toolName=Gotoh">Gotoh</a> algorithm
            </div>
        </div>


        The distances computed with the given formula are then used
        to create a phylogenetic tree with a hierarchical clustering algorithm.
        In the original
        <a href="https://doi.org/10.1007/BF02603120">Feng-Doolittle</a>
        approach, the clustering algorithm
        of <a href="10.1126/science.155.3760.279">Walter M. Fitch and Emanuel Margoliash (1967)</a>
        has been used.
        <br>
        But, our implementation instead utilizes the UPGMA algorithm
        by Robert R. Sokal and Charles D. Michener (1958) from the article
        "A statistical method for evaluating systematic relationship". <!-- couldn't found DOI-link -->
        <br>
        Once the phylogenetic tree is computed,
        it tells the order in which sequences or groups of sequences
        have to be aligned together to create a multi-sequence-alignment (MSA).
        <br>
        In this connection the "once a gap, always a gap"-rule is applied
        by substituting gaps in groups of sequences
        with a neutral symbol $\#$ before aligning them ($s(\cdot,\#) = s(\#,\cdot) = 0$).
        <br>
        The rule ensures that before made gaps in some subgroup
        of sequences are preserved.
        <br>
        <br>
        For a given input, the stated computation steps
        <ul>
            <li>pairwise alignment-data</li>
            <li>distance matrix</li>
            <li>phylogenetic tree</li>
            <li>merging</li>
        </ul>
        are calculated and represented in reverse order below. <br>
    </div>

    <div class="picture">
        <img src="Feng-Doolittle-120x90.png">
    </div>
</div>

<div id="algorithm_input">
    <!-- ko foreach: $root.input.sequences() -->
        <div class="row">
            <div class="colW100">
                <label>
                    Sequence <span data-bind="text: $root.input.clusterNames()[$index()]"></span>:
                </label>
            </div>

            <div class="colW175">
                <input class="sequence" data-bind="value: $data" placeholder="EXAMPLE 'ATC'" type="text">

                <!-- ko if: $index() == $root.input.clusterNames().length-1 -->
                    <div class="group_hint">
                        <b>Hint:</b> <br>
                        The "+" and "-" buttons can be used to add or remove sequences.
                        <br>
                        <br>
                        <b>Hint 2:</b> <br>
                        Duplicates of sequences <br>
                        are excluded from computations.
                        <!-- This is a bigger code readability and runtime enhancement:
                        sequences are stored as keys in hash-tables and
                        two times the same key is not possible in a hash-table! -->
                    </div>
                <!-- /ko -->
            </div>

            <!-- ko if: $index() == $root.input.clusterNames().length-1 -->
                <button class="add_remove" data-bind="click: $root.input.addRow" title="Add Sequence" type="button">+</button>
            <!-- /ko -->

            <!-- ko if: $index() == $root.input.clusterNames().length-1 && $root.input.clusterNames().length > 2 -->
                <button class="add_remove" data-bind="click: $root.input.removeRow" title="Remove Sequence" type="button">-</button>
            <!-- /ko -->
        </div>
    <!-- /ko -->

    <div class="row">
		<div class="colW100"><label>Scoring in $s$:</label></div>

		<div class="colW400">
            <span class="group"> <!-- Microsoft Browsers will fallback on text-fields using following input type -->
                Match <input class="fx_parameter" data-bind="value: input.match" id="match" type="number">
                Mismatch <input class="fx_parameter" data-bind="value: input.mismatch" id="mismatch" type="number">
            </span>
		</div>
    </div>

    <div class="row">
		<div class="colW100"><label>Scoring in $g$:</label></div>

		<div class="colW400">
            <span class="group"> <!-- Microsoft Browsers will fallback on text-fields using following input type -->
                Gap opening $\alpha$ <input class="fx_parameter" data-bind="value: input.baseCosts" id="base_costs" type="number">
                Enlargement $\beta$ <input class="fx_parameter" data-bind="value: input.enlargement" id="enlargement" type="number">
            </span>
            <br>
            <br>
            <span data-bind="text: $root.input.gapFunction"></span>

            <div class="group_hint">
				<b>Hint:</b> <br>
				For similarity maximization, <br> match scores should be positive and all other scores lower. <br>
			</div>
		</div>
    </div>
</div>

<div id="algorithm_output">
    <div class="output">
        <div class="final">
            <table class="final_result_header">
                <thead>
					<tr>
						<th>
                            Final result
						</th>
					</tr>
                </thead>
            </table>

            <div class="final_result_with_scrollbar">
                <table class="final_result">
                    <tbody>
                        <tr>
                            <td class="entry entry_start">
                                <!-- ko foreach: $root.output.progressiveAlignment() -->
                                    <code data-bind="text: $root.output.progressiveAlignment()[$index()]"></code> <br>
                                <!-- /ko -->
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="intermediate_result_header">
            <h4>Intermediate Results</h4>
        </div>

        <div class="merge_steps">
            <table class="result_header">
                <thead>
					<tr>
						<th>
                            Merge steps
						</th>
					</tr>
                </thead>
            </table>

            <div class="result_with_scrollbar">
                <table class="result_categories">
                    <thead>
                        <tr>
                            <th>
                                <small><b>Group 1</b></small>
                            </th>

                            <th>
                                <small><b>Group 2</b></small>
                            </th>

                            <th>
                                <small><b>Guide Alignment</b></small>
                            </th>

                            <th>
                                 <small><b>Result</b></small>
                            </th>
                        </tr>
                    </thead>

                    <tbody>
                        <!-- ko foreach: $root.output.guideAlignments() -->
                            <tr>
                                <td class="entry entry_start">
                                    <!-- ko foreach: $root.output.firstGroups()[$index()] -->
                                        <code data-bind="text: $data"></code> <br>
                                    <!-- /ko -->
                                </td>

                                <td class="entry entry_start">
                                    <!-- ko foreach: $root.output.secondGroups()[$index()] -->
                                        <code data-bind="text: $data"></code> <br>
                                    <!-- /ko -->
                                </td>

                                <td class="entry entry_start">
                                    <code data-bind="text: $root.output.guideAlignments()[$index()][0]"></code> <br>
                                    <code data-bind="text: $root.output.guideAlignments()[$index()][1]"></code> <br>
                                    <code data-bind="text: $root.output.guideAlignments()[$index()][2]"></code>
                                </td>

                                 <td class="entry entry_start">
                                     <code data-bind="text: $root.output.joinedGroupNames()[$index()]"></code>:
                                     <!-- ko foreach: $root.output.joinedGroups()[$index()] -->
                                        <!-- ko if: $index() == 0 -->
                                            <code data-bind="text: $data"></code> <br>
                                        <!-- /ko -->

                                        <!-- ko if: $index() != 0 -->
                                            <code>  </code><code data-bind="text: $data"></code> <br>
                                        <!-- /ko -->
                                     <!-- /ko -->
                                </td>
                            </tr>
                         <!-- /ko -->
                    </tbody>
                </table>
            </div>
        </div>

        <div class="intermediate_result_header">
            <h4 class="subresult">Phylogenetic Tree</h4>
        </div>

        <div class="newick_tree">
            <table class="result_header">
                <thead>
					<tr>
						<th>
                            Newick Tree
						</th>
					</tr>
                </thead>
            </table>

            <div class="result_with_scrollbar">
                <table class="result">
                    <tbody>
                        <tr>
                            <td class="entry entry_start">
                                <code data-bind="text: $root.output.newickString()"></code>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="tree_container"> <!-- allows to delete and reinsert the div -->
            <div id="phylogenetic_tree"></div>
        </div>

        <div class="group_hint">
            <b>Visualization done with</b> <br>
            Smits SA, Ouverney CC, 2010. jsPhyloSVG: <br>
            A Javascript Library for Visualizing Interactive and Vector-Based Phylogenetic Trees on the Web. <br>
            <a href="http://www.plosone.org/article/info:doi/10.1371/journal.pone.0012267">
                PLoS ONE 5(8): e12267. doi:10.1371/journal.pone.0012267
            </a>
        </div>

        <div class="intermediate_result_header">
            <h4 class="subresult">Distance Table</h4>
        </div>

        <div class="distance_table">
            <table class="calculation">
                <thead>
                    <tr>
                        <th class="distance_table_header" colspan=100%>
                            Distance Table
                        </th>
                    </tr>

					<tr>
						<th></th>
                        <!-- ko foreach: input.clusterNames() -->
                            <!-- ko if: $index() < $root.output.distanceMatrix()[0].length -->
							    <th data-bind="drawChar: [$data, undefined]"></th>
                            <!-- /ko -->
                        <!-- /ko -->
					</tr>
                </thead>

                <tbody>
					<!-- ko foreach: $root.output.distanceMatrix() --> <!-- to get i-indexes = $parentContext.$index() -->
						<tr>
                            <!-- ko if: $index() < $root.output.distanceMatrix()[0].length --> <!-- works because of a symmetric matrix -->
                                <th data-bind="drawChar: [$root.input.clusterNames()[$index()], undefined]"></th>

                                <!-- ko foreach: $root.output.distanceMatrix()[0] --> <!-- to get j-indexes = $index() -->
                                    <td class="non_selectable_entry"
                                        data-bind="text: $root.output.distanceMatrix()[$parentContext.$index()][$index()]"></td>
                                <!-- /ko -->
                            <!-- /ko -->
						</tr>
                    <!-- /ko -->
                </tbody>
            </table>
        </div>

        <div class="download_area">
            <a class="distance_table_download" href="#">Download Table</a>
        </div>
    </div>
</div>