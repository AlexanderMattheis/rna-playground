


 http://stackoverflow.com/questions/4712189/how-to-draw-a-line-between-2-elements-using-jquery-and-refreshing-that-line

- generate dedicated divs and tables (always present and only filled by JS) with fixed RELATIVE arrangements for 
 + the output table
 + the optimal structure (shown above the subopt list) = js-link for trace-visualization
 + the list of subopt structures = each a js-link for trace-visualization
 + the info box above the table (full width)
 + a canvas that is used for line + info drawings

- JS: "fillMatrix()"
 + takes a nussinov object N
 + removes the content of the table
 + fills the table with rows and cells (id="row_col") according to N
 + add one row in the top for the structure output

- JS: "drawCellConnection()"
 + input = two cell ids
 + draws a line between the cells depending on the relative positioning of the two cells (if same row/column: between mid of closest borders, if diagonal: between closest corners)

- JS: "setCellColor()"
 + sets the background color of a cell

- JS: "visualizeTraceback()" 
 + has a traceback as input
 + refreshs the canvas
 + calls "drawCellConnection()" for each trace step
 + assigns an according cell color using "setCellColor()"
 + update according structure cells from the table to represent the structure in the top

- JS: "drawCellAnnotation()"
 + input a cell id and a text
 + draws a rectangle above the upper right corner of the cell with the given text within (or just add the text)

- JS: "visualizeTrace()"
 + has one trace step as an input
 + refresh the cancas
 + set cell colors "setCellColor()" and draw lines "drawCellConnection()"
 + "drawCellAnnotation()" if base pair added

- JS: write according helper functions to react on user selections, e.g. you can have one click-listener for the whole table which identifies the cell clicked by accessing the html-element via the clicked position (we have similar stuff within our webserver already). by this you get the element-id which encodes (within the table) the according cell position, such that you can do the right reaction to the click. this way you dont have to register a lot of listeners to all the cells generated by "fillMatrix()"


what are the advantages:
- should be faster
- should enable html/latex rendering within the table
- html & JS source code is readable and maintainable
- should be reusable for other algorithms (e.g. "fillMatrix()" can be used for counting stuff etc.) 
- enables easy CSS styling




interface:

- add "i" and "j" label to according dimension - hmmm ?


COUNTING page:
- implement counting algorithm
- show latex recursion
- input: sequence + loop length
- output: counting table (without interaction)

McCaskill page:
- algorithm: parameter c=b=0, a=eH=eSBI=-1
- add loop length m = matrix initialization for m diagonals and according shifted matrix computation
- input: sequence + loop length
- output: give overall partition function Z (=Q[1,n]) + list of all tables (without interaction)

McCaskill-2:
- implement base pair probabilities extending the McCaskill implementation (fill matrix from outside to inside = start computation with p1n)
- extend McCaskill output: bp-dotplot above all other tables (contact martin for JS dot-plot-viz)

McCaskill-3:
- implement unpaired probabilities extending the McCaskill implementation
- extend McCaskill output: add "unpaired-dot-plot" below bp-dotplot

