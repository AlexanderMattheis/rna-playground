<!--
University of Freiburg WS 2017/2018
Chair for Bioinformatics
Supervisor: Martin Raden
Author: Alexander Mattheis
-->

<div id="algorithm_description">
    <div class="description"> <!-- what-why-how description -->
        <a href="http://dx.doi.org/10.1006/jmbi.2000.4042">C&eacute;dric Notredame, Desmond G. Higgins and Jaap Heringa</a>
        introduced 2000 an approach that
        allows a very accurate computation of multiple sequence alignments (MSA),
        the Tree-based Consistency Objective Function for alignment Evaluation (short: <em>T-coffee</em>).
        It's a tree-based approach,
        because it uses a progressive alignment strategy
        under a consistency based function with a guide tree
        (tree can be computed with <a href="http://rna.informatik.uni-freiburg.de/Teaching/index.jsp?toolName=Feng-Doolittle">Feng-Doolittle</a>).
        The advantage to traditional approaches like
        <a href="https://doi.org/10.1007/BF02603120">Feng-Doolittle (1987)</a>
        is that the results are much better since they are not based on single pairwise alignments,
        but rather an arbitrary large pool of alignments with which a position specific scoring function is computed,
        the so called extended library $EL^{a,b}_{i,j}$
        where $a,b$ are arbitrary sequences and $i,j$ are locations within these sequences.
        <br>
        <br>
	    But, first the primary library $L^{a,b}_{i,j}$ is computed.
        It stores information about the accuracy of an alignment $\mathcal{A}(a,b)$.
        This is done with the formula for the sequence identity:

        $$
        \quad
        L^{a,b}_{i,j} = weight \big(\mathcal{A}(a,b) \big)
        = \frac {matches \big(\mathcal{A}(a,b) \big)}
                {matches \big(\mathcal{A}(a,b) \big) + mismatches \big(\mathcal{A}(a,b) \big)} \cdot 100 \quad \forall i,j
        $$

        where $L^{a,b}_{i,j} = L^{b,a}_{j,i}$ ($L^{a,b}_{i,j} = 0$ for not defined locations $i,j$) <br>
        The extended library instead is calculated to gather consistency information
        concerning all other alignments (i.e. to emphasize columns with matches), different to $\mathcal{A}(a,b)$.
        That is done by the consideration of all sequence triples,
        as shown in the following formula:

        $$
        \quad
        EL^{a,b}_{i,j}
        = L^{a,b}_{i,j} + \sum_{x \in \mathbb{S} \setminus \{a,b\}} \sum_{k \in Loc(x)} min \big(L^{a,x}_{i,k}, L^{x,b}_{k,j} \big)
        $$

        where <br>
        <div class="row">
            <div class="colW150">$\mathbb{S} \setminus \{a,b\}$</div>
            <div class="colW400">set of all sequences different from $\{a,b\}$</div>
	    </div>

        <div class="row">
            <div class="colW150">$Loc(x)$</div>
            <div class="colW400">set of all locations/positions in x</div>
        </div>

        Afterwards this scoring function $EL^{a,b}_{i,j}$ is used in a modified neighbour joining (fusion) process
        of <a href="http://rna.informatik.uni-freiburg.de/Teaching/index.jsp?toolName=Feng-Doolittle">Feng-Doolittle</a>
        to compute a multiple sequence alignment.
        Unlike in the <a href="https://doi.org/10.1007/BF02603120">Feng-Doolittle (1987)</a> approach,
        the whole columns of two groups aligned together.
        Therefore, the average alignment score of two columns is used
        (all chars of first column aligned with all chars of second column).
        And gaps are ignored by setting $\alpha = \beta = 0$, because the library
        is computed on alignments in which such parameters have been already applied.
        <br>
        <br>
        In the algorithm, it is possible to add information
        from arbitrary alignments to emphasize particularly important
        positions of together aligned sequences.
        This is done in our case with local alignments, for which with the given sequence identity formula above
        a local primary library is computed and added to the values of the global primary library
        i.e. $L^{a,b}_{i,j} = {L^{a,b}_{i,j}}_{loc} + {L^{a,b}_{i,j}}_{glob}$
        (originally ten alignments with highest scores are chosen for the local primary library).
        <br>
        <br>
        For a given input, the stated computation steps generate the
        <ul>
            <li>primary and extended library</li>
            <li>phylogenetic tree</li>
            <li>MSA via fusions</li>
            <li>multiple sequence alignment (MSA) with SoP score</li>
        </ul>
        and are represented in reversed order below.
    </div>

    <div class="picture">
        <img src="Notredame-Higgins-Heringa-120x90.png">
    </div>
</div>

<h1>Input:</h1>
<div id="algorithm_input">
    <!-- ko foreach: $root.input.sequences() -->
        <div class="row">
            <div class="colW100">
                <label>
                    Sequence <span data-bind="text: $root.input.clusterNames()[$index()]"></span>:
                </label>
            </div>

            <div class="colW225">
                <input class="sequence_multi" data-bind="value: $data" placeholder="EXAMPLE 'ATC'" type="text">

                <!-- ko if: $index() == $root.input.clusterNames().length-1 -->
                    <div class="group_hint">
                        <b>Hint:</b> <br>
                        The "+" and "-" buttons can be used to add or remove sequences.
                        Duplicates of sequences <br>
                        are excluded from computations.
                        <!-- The distance formula
                        is not defined for two sequences of same type,
                        because the denominator gets zero.
                        Also, this allows a bigger code readability and runtime enhancement:
                        Sequences are stored as keys in hash-tables and
                        two times the same key is not possible in a hash-table!
                        -->
                    </div>
                <!-- /ko -->
            </div>

            <!-- ko if: $index() == $root.input.clusterNames().length-1 -->
                <button class="add_remove" data-bind="click: $root.input.addRow" title="Add Sequence" type="button">+</button>
            <!-- /ko -->

            <!-- ko if: $index() == $root.input.clusterNames().length-1 && $root.input.clusterNames().length > 2 -->
                <button class="add_remove" data-bind="click: $root.input.removeRow" title="Remove Sequence" type="button">-</button>
            <!-- /ko -->
        </div>
    <!-- /ko -->

    <div class="row">
		<div class="colW100"><label>Scoring in $s$:</label></div>

		<div class="colW400">
            <span class="group"> <!-- Microsoft Browsers will fallback on text-fields using following input type -->
                Match <input class="fx_parameter" data-bind="value: input.match" id="match" type="number">
                Mismatch <input class="fx_parameter" data-bind="value: input.mismatch" id="mismatch" type="number">
            </span>
		</div>
    </div>

    <div class="row">
		<div class="colW100"><label>Scoring in $g$:</label></div>

		<div class="colW400">
            <span class="group"> <!-- Microsoft Browsers will fallback on text-fields using following input type -->
                Gap opening $\alpha$ <input class="fx_parameter" data-bind="value: input.baseCosts" id="base_costs" type="number">
                Enlargement $\beta$ <input class="fx_parameter" data-bind="value: input.enlargement" id="enlargement" type="number">
            </span>
            <br>
            <br>
            <span data-bind="text: $root.input.gapFunction"></span>

            <div class="group_hint">
				<b>Hint:</b> <br>
				For similarity maximization, <br> match scores should be positive and all other scores lower. <br>
			</div>
		</div>
    </div>

    <div class="row">
        <div class="colW100"><label>Add local library</label></div>
        <div class="colW400"><input data-bind="checked: $root.input.useLocalLibrary" type="checkbox"></div>
    </div>

    <div class="localLibraryParameters" data-bind="visible: $root.input.useLocalLibrary">
        <h2 class="input_heading">Local Library Parameters</h2>
        <div class="row">
            <div class="colW100"><label>Scoring in $s$:</label></div>

            <div class="colW400">
                <span class="group"> <!-- Microsoft Browsers will fallback on text-fields using following input type -->
                    Match <input class="fx_parameter" data-bind="value: input.matchLocal" id="match_local" type="number">
                    Mismatch <input class="fx_parameter" data-bind="value: input.mismatchLocal" id="mismatch_local" type="number">
                </span>
            </div>
        </div>

        <div class="row">
            <div class="colW100"><label>Scoring in $g$:</label></div>

            <div class="colW400">
                <span class="group"> <!-- Microsoft Browsers will fallback on text-fields using following input type -->
                    Gap opening $\alpha$ <input class="fx_parameter" data-bind="value: input.baseCostsLocal" id="base_costs_local" type="number">
                    Enlargement $\beta$ <input class="fx_parameter" data-bind="value: input.enlargementLocal" id="enlargement_local" type="number">
                </span>
                <br>
                <br>
                <span data-bind="text: $root.input.gapFunctionLocal"></span>

                <div class="group_hint">
                    <b>Hint:</b> <br>
                    For similarity maximization, <br> match scores should be positive and all other scores lower. <br>
                </div>
            </div>
        </div>
    </div>
</div>

<h1>Output:</h1>
<div id="algorithm_output">
    <div class="final">
            <table class="final_result_header">
                <thead>
                    <tr>
                        <th>
                            Final result
                        </th>
                    </tr>
                </thead>
            </table>

            <div class="final_result_with_scrollbar">
                <table class="final_result">
                    <tbody>
                        <tr>
                            <td class="entry entry_start">
                                <!-- ko foreach: $root.output.progressiveAlignment() -->
                                    <code data-bind="text: $root.output.progressiveAlignment()[$index()]"></code> <br>
                                <!-- /ko -->
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <table class="final_result_footer">
                <tr>
                    <th>
                        <small>
                            Affine SoP score: <span data-bind="text: $root.output.score()"></span>
                        </small>
                    </th>
                </tr>
            </table>
        </div>

        <h2>Intermediate Results</h2>

        <div class="merge_steps">
            <table class="result_header">
                <thead>
                    <tr>
                        <th>
                            Fusion steps
                        </th>
                    </tr>
                </thead>
            </table>

            <div class="result_with_scrollbar">
                <table class="result_categories">
                    <thead>
                        <tr>
                            <th>
                                <small><b>Group 1</b></small>
                            </th>

                            <th>
                                <small><b>Group 2</b></small>
                            </th>

                            <th>
                                 <small><b>Result</b></small>
                            </th>
                        </tr>
                    </thead>

                    <tbody>
                        <!-- ko foreach: $root.output.firstGroups() -->
                            <tr>
                                <td class="entry entry_start">
                                    <code data-bind="text: $root.output.firstGroupsNames()[$index()]"></code>: <br>
                                    <!-- ko foreach: $root.output.firstGroups()[$index()] -->
                                        <code data-bind="text: $data"></code> <br>
                                    <!-- /ko -->
                                </td>

                                <td class="entry entry_start">
                                    <code data-bind="text: $root.output.secondGroupsNames()[$index()]"></code>: <br>
                                    <!-- ko foreach: $root.output.secondGroups()[$index()] -->
                                        <code data-bind="text: $data"></code> <br>
                                    <!-- /ko -->
                                </td>

                                <td class="entry entry_start">
                                    <code data-bind="text: $root.output.joinedGroupNames()[$index()]"></code>: <br>
                                    <!-- ko foreach: $root.output.joinedGroups()[$index()] -->
                                        <code data-bind="text: $data"></code> <br>
                                    <!-- /ko -->
                                </td>
                            </tr>
                        <!-- /ko -->
                    </tbody>
                </table>
            </div>
        </div>

        <h2>Phylogenetic Tree</h2>
        <div class="newick_tree">
            <table class="result_header">
                <thead>
                    <tr>
                        <th>
                            Newick Tree
                        </th>
                    </tr>
                </thead>
            </table>

            <div class="result_with_scrollbar">
                <table class="result">
                    <tbody>
                        <tr>
                            <td class="entry entry_start">
                                <code data-bind="text: $root.output.newickString()"></code>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="tree_container"> <!-- allows to delete and reinsert the div -->
            <div id="phylogenetic_tree"></div>
        </div>

        <!-- ko if: $root.output.newickString().length !== 1 && $root.output.newickString().indexOf(SYMBOLS.MINUS) === -1 -->
            <div class="group_hint">
                <b>Visualization done with</b> <br>
                Smits SA, Ouverney CC, 2010. jsPhyloSVG: <br>
                A Javascript Library for Visualizing Interactive and Vector-Based Phylogenetic Trees on the Web. <br>
                <a href="http://www.plosone.org/article/info:doi/10.1371/journal.pone.0012267">
                    PLoS ONE 5(8): e12267. doi:10.1371/journal.pone.0012267
                </a>
            </div>
        <!-- /ko -->

        <div class="group_hint">
            <b>Hint: </b> Visualization is only shown, if there are no negative distances.
        </div>


        <h2>Libraries</h2>
        <div class="pairwise_data">
            <div class="result_with_scrollbar">
                <table class="result_categories top_border">
                    <thead>
                        <tr>
                            <th>
                                <small><b>Sequence Pair</b></small>
                            </th>

                            <th>
                                <small><b>Position Pair</b></small>
                            </th>

                            <th>
                                <small><b>Primary Library $L$</b></small>
                            </th>

                            <th>
                                <small><b>Extended Library $EL$</b></small>
                            </th>
                        </tr>
                    </thead>

                    <tbody>
                        <!-- ko foreach: $root.output.sequencePairsNames() -->
                            <tr>
                                <td class="entry entry_start">
                                    <code>(</code><code data-bind="text: $data[0]"></code><code>,</code>
                                    <code data-bind="text: $data[1]"></code><code>)</code>
                                    <br>
                                </td>

                                <td class="entry entry_start">
                                    <!-- ko foreach: $root.output.libPositionPairs()[$index()] -->
                                        <code>(</code><code data-bind="text: $data"></code><code>)</code> <br>
                                    <!-- /ko -->
                                </td>

                                <td class="entry entry_start">
                                    <!-- ko foreach: $root.output.primLibValues()[$index()] -->
                                        <code data-bind="text: $data"></code> <br>
                                    <!-- /ko -->
                                </td>

                                <td class="entry entry_start">
                                    <!-- ko foreach: $root.output.extendedLibValues()[$index()] -->
                                        <code data-bind="text: $data"></code> <br>
                                    <!-- /ko -->
                                </td>
                            </tr>
                        <!-- /ko -->
                    </tbody>
                </table>
            </div>

            <table class="pairwise_data_footer">
                <tr>
                    <th>
                        <small>
                            <b>Hint:</b> Only sequence pairs with alignment length bigger zero displayed!
                        </small>
                    </th>
                </tr>
            </table>
        </div>
</div>
