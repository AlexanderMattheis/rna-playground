<!--
University of Freiburg WS 2017/2018
Chair for Bioinformatics
Supervisor: Martin Raden
Author: Alexander Mattheis
-->

<div id="algorithm_description">
    <div class="description"> <!-- what-why-how description -->
        <a href="http://dx.doi.org/10.1006/jmbi.2000.4042">C&eacute;dric Notredame, Desmond G. Higgins and Jaap Heringa</a>
        introduced 2000 an approach that
        allows a very accurate computation of multiple sequence alignments (MSA),
        the Tree-based Consistency Objective Function for alignment Evaluation (short: <em>T-coffee</em>).
        It's a tree-based,
        because it uses a progressive alignment strategy
        with a consistency based function and a given guide tree.
        The advantage to traditional approaches like
        <a href="https://doi.org/10.1007/BF02603120">Feng-Doolittle (1987)</a>
        is that the results are much better since they are not based on single pairwise alignments,
        but rather an arbitrary large pool of alignments in which the best alignments are chosen
        to compute a position specific scoring function, the so called extended library $EL^{a,b}_{i,j}$
        where $a,b$ are arbitrary sequences and $i,j$ are locations within these sequences.
        <br>
        <br>
	    But, first the primary library $L^{a,b}_{i,j}$ is computed.
        It stores information about the accuracy of an alignment $\mathcal{A}(a,b)$.
        This is done with the formula for the sequence identity:

        $$
        \quad
        L^{a,b}_{i,j} = weight \big(\mathcal{A}(a,b) \big)
        = \frac {matches \big(\mathcal{A}(a,b) \big)}
                {matches \big(\mathcal{A}(a,b) \big) + mismatches \big(\mathcal{A}(a,b) \big)} \quad \forall i,j
        $$

        where $L^{a,b}_{i,j} = L^{b,a}_{j,i}$ ($L^{a,b}_{i,j} = 0$ for not defined locations $i,j$) <br>
        The extended library instead is calculated to gather consistency information
        concerning all other alignments, different to $\mathcal{A}(a,b)$.
        That is done by the consideration of all sequence triples,
        as shown in the following formula:

        $$
        \quad
        EL^{a,b}_{i,j}
        = L^{a,b}_{i,j} + \sum_{x \in \mathbb{S} \setminus \{a,b\}} \sum_{k \in Loc(x)} min \big(L^{a,x}_{i,k}, L^{x,b}_{k,j} \big)
        $$

        where <br>
        <div class="row">
            <div class="colW150">$\mathbb{S} \setminus \{a,b\}$</div>
            <div class="colW400">set of all sequences different from $\{a,b\}$</div>
	    </div>

        <div class="row">
            <div class="colW150">$Loc(x)$</div>
            <div class="colW400">set of all locations/positions in x</div>
        </div>

        The minimum weight $min \big(L^{a,x}_{i,k}, L^{x,b}_{k,j} \big)$
        through a sequence different to sequences $a$ and $b$
        is added to the current weight $L^{a,b}_{i,j}$ of an alignment $a$ with $b$.
        And afterwards this scoring function $EL^{a,b}_{i,j}$ is used in a modified neighbour joining (fusion) process
        of <a href="http://rna.informatik.uni-freiburg.de/Teaching/index.jsp?toolName=Feng-Doolittle">Feng-Doolittle</a>
        to compute a multiple sequence alignment.
        Unlike in the <a href="https://doi.org/10.1007/BF02603120">Feng-Doolittle (1987)</a> approach,
        the whole columns of two groups aligned together.
        Therefore, the average alignment score of two columns is used
        (all chars of first column aligned with all chars of second column).
        <br>
        <br>
        For a given input, the stated computation steps generate the
        <ul>
            <li>primary library</li>
            <li>extended library</li>
            <li>multiple sequence alignment (MSA) with SoP score</li>
        </ul>
        and are represented in reversed order below.
    </div>

    <div class="picture">
        <img src="Notredame-Higgins-Heringa-120x90.png">
    </div>
</div>

<h1 class="header">Input:</h1>
<div id="algorithm_input">
    <!-- ko foreach: $root.input.sequences() -->
        <div class="row">
            <div class="colW100">
                <label>
                    Sequence <span data-bind="text: $root.input.clusterNames()[$index()]"></span>:
                </label>
            </div>

            <div class="colW225">
                <input class="sequence" data-bind="value: $data" placeholder="EXAMPLE 'ATC'" type="text">

                <!-- ko if: $index() == $root.input.clusterNames().length-1 -->
                    <div class="group_hint">
                        <b>Hint:</b> <br>
                        The "+" and "-" buttons can be used to add or remove sequences.
                        Duplicates of sequences <br>
                        are excluded from computations.
                        <!-- The distance formula
                        is not defined for two sequences of same type,
                        because the denominator gets zero.
                        Also, this allows a bigger code readability and runtime enhancement:
                        Sequences are stored as keys in hash-tables and
                        two times the same key is not possible in a hash-table!
                        -->
                    </div>
                <!-- /ko -->
            </div>

            <!-- ko if: $index() == $root.input.clusterNames().length-1 -->
                <button class="add_remove" data-bind="click: $root.input.addRow" title="Add Sequence" type="button">+</button>
            <!-- /ko -->

            <!-- ko if: $index() == $root.input.clusterNames().length-1 && $root.input.clusterNames().length > 2 -->
                <button class="add_remove" data-bind="click: $root.input.removeRow" title="Remove Sequence" type="button">-</button>
            <!-- /ko -->
        </div>
    <!-- /ko -->

    <div class="row">
		<div class="colW100"><label>Scoring in $s$:</label></div>

		<div class="colW400">
            <span class="group"> <!-- Microsoft Browsers will fallback on text-fields using following input type -->
                Match <input class="fx_parameter" data-bind="value: input.match" id="match" type="number">
                Mismatch <input class="fx_parameter" data-bind="value: input.mismatch" id="mismatch" type="number">
            </span>
		</div>
    </div>

    <div class="row">
		<div class="colW100"><label>Scoring in $g$:</label></div>

		<div class="colW400">
            <span class="group"> <!-- Microsoft Browsers will fallback on text-fields using following input type -->
                Gap opening $\alpha$ <input class="fx_parameter" data-bind="value: input.baseCosts" id="base_costs" type="number">
                Enlargement $\beta$ <input class="fx_parameter" data-bind="value: input.enlargement" id="enlargement" type="number">
            </span>
            <br>
            <br>
            <span data-bind="text: $root.input.gapFunction"></span>

            <div class="group_hint">
				<b>Hint:</b> <br>
				For similarity maximization, <br> match scores should be positive and all other scores lower. <br>
			</div>
		</div>
    </div>
</div>

<div id="algorithm_output">
</div>
